// Copyright(c) 2024 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/linuxkit/linuxkit/src/cmd/linuxkit/moby"
	"github.com/moby/buildkit/frontend/dockerfile/instructions"
	"github.com/moby/buildkit/frontend/dockerfile/parser"
)

const (
	MAKEFILE = 0 // Generate makefile auxiliary file as output
	IMG = 1 // Generate a PNG image as output
)

var (
	outputImgFile string
	outputMakeFile string
	rootfsDeps bool
)

// Parse YML file and return all lfedge/* packages inside it
func parseYMLfile(fileName string) []string {
	var deps []string

	// Open and read the file
	bs, err := os.ReadFile(fileName)
	if err != nil {
		log.Fatal(err)
	}

	// Parses the file
	m, err := moby.NewConfig(bs, func(path string) (tag string, err error) {
		return path, nil
	})
	if err != nil {
		log.Fatal(err)
	}

	deps = append(deps, m.Init...)
	for _, img := range m.Onboot {
		deps = append(deps, img.Image)
	}
    for _, img := range m.Onshutdown {
		deps = append(deps, img.Image)
	}
	for _, img := range m.Services {
		deps = append(deps, img.Image)
	}

	return deps
}

// Parse Dockerfile and return all packages from FROM command
func parseDockerfile(f *os.File) []string {
	var fromsCmd []string
	result, err := parser.Parse(f)
	if err != nil {
		log.Fatalf("parsing %s failed: %+v", f.Name(), err)
	}

	vars := parseVars(result)
	var next *parser.Node
	for _, node := range result.AST.Children {
		if node.Value == "FROM" {
			next = node.Next
			if next == nil {
				break
			}
			from := expandVariables(next, vars)
			fromsCmd = append(fromsCmd, from)
		}
	}

	return fromsCmd
}

// Expand variables from Dockerfile
func expandVariables(next *parser.Node, vars map[string]string) string {
	from := next.Value
	for key, val := range vars {
		from = strings.ReplaceAll(from, fmt.Sprintf("${%s}", key), val)
	}
	return from
}

// Parse variables from Dockerfile
func parseVars(result *parser.Result) map[string]string {
	vars := make(map[string]string)
	_, metaArgs, err := instructions.Parse(result.AST)
	if err != nil {
		log.Fatal(err)
	}

	for _, argCmd := range metaArgs {
		if argCmd.Name() != "ARG" {
			continue
		}
		for _, argCmdArg := range argCmd.Args {
			vars[argCmdArg.Key] = argCmdArg.ValueString()
		}
	}

	return vars
}

// Print a single dependency package, only suitable for dot file
func printSingleDep(t int, dep string) string {
	if t == IMG {
		return "\"" + dep + "\";"
	}
	return ""
}

// Print a package and one of its dependency
func printDep(t int, pkg string, dep string) string {
	if t == MAKEFILE {
		return pkg + ": " + dep + "\n"
	} else {
		return "\"" + pkg + "\" -> \"" + dep + "\";\n"
	}
}

// Print the header and/or the initialization commands (for dot file)
func printHead(t int) string {
	if t == MAKEFILE {
		return "#\n# This file was generated by EVE's build system. DO NOT EDIT.\n#\n"
	} else {
		return "digraph unix {\n   rankdir=\"LR\";\n"
	}
}

// Print the end of the generated file
func printTail(t int) string {
	if t == IMG {
		return "\n}\n"
	}
	return ""
}

// Filter packages from the list of dependencies
func filterPkg(deps []string) []string {
	var depList []string
	dpList := make(map[string]bool)

	reLF  := regexp.MustCompile("lfedge/.*")
	rePkg := regexp.MustCompile("lfedge/(?:eve-)?(.*):.*")
	for _, s := range deps {
		// We are just interested on packages from lfegde (those that we
		// published)
		if reLF.MatchString(s) {
			str := rePkg.ReplaceAllString(s, "pkg/$1")
			if !dpList[str] {
				dpList[str] = true
				depList = append(depList, str)
			}
		}
	}

	return depList
}

// Return a list of all dependencies (packages) listed in a Dockerfile
func getDeps(dockerfile string) []string {
	var depList []string
	f, err := os.Open(dockerfile)
	if err != nil {
		fmt.Println(err)
		return depList
	}
	defer f.Close()
	ss := parseDockerfile(f)
	return filterPkg(ss)
}

// Write string to file with error checking
func writeToFile(f *os.File, str string) {
	_, err := f.WriteString(str)
	if err != nil {
		fmt.Println(err)
	}
}

func main() {
	mkfile := false
	imgfile := false
	pkgName := ""
	t := MAKEFILE

	// Build and validate the command line
	flag.Usage = func() {
		fmt.Printf("Create dependency packages tree\n\n")
		fmt.Printf("Use:\n    %s [-r] <-i|-m> <output_file>\n\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.StringVar(&outputImgFile, "i", "", "Generate a PNG image file")
	flag.StringVar(&outputMakeFile, "m", "", "Generate a Makefile auxiliary file")
	flag.BoolVar(&rootfsDeps, "r", false, "Also generates dependencies for rootfs image")
	flag.Parse()

	if len(outputImgFile) > 0 {
		imgfile = true
		t = IMG
	}
	if len(outputMakeFile) > 0 {
		mkfile = true
		t = MAKEFILE
	}
	if !imgfile && !mkfile {
		flag.Usage()
		os.Exit(1)
	} else if imgfile && mkfile {
		flag.Usage()
		log.Fatal("Only one type of output dependency tree can be provided.\n")
	}

	// Create the output file, if we are generating image tree, then an
	// intermediate file (.dot) must be created
	var outfile *os.File
	var errF error
	if t == IMG {
		outfile, errF = os.CreateTemp("", "eve-dot-")
		if errF != nil {
			log.Fatal(errF)
		}
	} else {
		outfile, errF = os.Create(outputMakeFile)
		if errF != nil {
			log.Fatal(errF)
		}
	}

	// Beginning of the output file
	writeToFile(outfile, printHead(t))

	// Scan all directories of pkg/
	ent, err := os.ReadDir("./pkg")
	if err != nil {
		log.Fatal(err)
	}
	for _, e := range ent {
		if !e.IsDir() {
			continue
		}
		dockerFile := "./pkg/" + e.Name() + "/Dockerfile"
		dockerFileIn := dockerFile + ".in"
		rmDockerfile := false

		if _, err := os.Stat(dockerFile); err != nil {
			if _, errIn := os.Stat(dockerFileIn); errIn == nil {
				// Process Dockerfile.in
				cmd := exec.Command("./tools/parse-pkgs.sh", dockerFileIn)
				out, err := cmd.Output()
				if err != nil {
					log.Println("Failed to process", dockerFileIn)
					continue
				}

				f, errTmp := os.CreateTemp("", "eve-dockerfile-")
				if errTmp != nil {
					log.Println(errTmp)
					continue
				}
				dockerFile = f.Name()
				rmDockerfile = true
				if _, errW := f.Write(out); errW != nil {
					log.Println("Failed to write to", dockerFile)
					continue
				}
				f.Close()
			} else {
				continue
			}

			pkgName = "pkg/" + e.Name()
		} else {
			pkgName = filepath.Dir(dockerFile)
		}

		// Get package dependencies from Dockerfile
		writeToFile(outfile, printSingleDep(t, pkgName))
		depList := getDeps(dockerFile)
		for _, d := range depList {
			if d != pkgName {
				// Write a single dependency of the package
				writeToFile(outfile, printDep(t, pkgName, d))
			}
		}

		// Remove temporary file (if needed)
		if rmDockerfile {
			os.Remove(dockerFile)
		}
	}

	// Scan rootfs dependencies
	if rootfsDeps {
		ent, err = os.ReadDir("./images/out/")
		if err == nil {
			for _, e := range ent {
				if !e.IsDir() {
					// Process yml file
					ymlFile := "images/out/" + e.Name()
					depYML := parseYMLfile(ymlFile)
					depList := filterPkg(depYML)
					for _, d := range depList {
						writeToFile(outfile, printDep(t, ymlFile, d))
					}
				}
			}
		}
	}

	// We reach the end of the file
	writeToFile(outfile, printTail(t))
	outfileName := outfile.Name()
	outfile.Close()

	// Check if we need to generate the image
	if t == IMG {
		_, err := exec.Command("dot", "-Tpng", outfileName, "-o", outputImgFile).Output()
		if err != nil {
			fmt.Println("Failed to run dot utility.")
		}
		// Remove temporary file
		os.Remove(outfileName)
		// Set the final output file name
		outfileName = outputImgFile
	}

	fmt.Println("Done. Output file written to " + outfileName + ".")
}
